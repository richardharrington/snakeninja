<!DOCTYPE HTML>
<html lang="en-US">
<head>
	<meta charset="UTF-8">
	<title></title>
	<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
	<script src="http://cdnjs.cloudflare.com/ajax/libs/underscore.js/1.3.3/underscore-min.js"></script>
</head>
<style type="text/css">
	#mainCanvas {
		border: solid 3px #888;
		margin: 35px;
	}
</style>
<body>
	<canvas id="mainCanvas"></canvas>

<script type="text/javascript">

	var LINE_CAP = 'butt';
	var LINE_JOIN = 'miter';
	var INTERVAL_TIME = 50; // seconds
	var BLOCK_HEIGHT = 10;
	var GRID_SIZE = 40; // just make sure BLOCK_HEIGHT is divisible by GRID_SIZE, for now.
	var PLAYER_ONE_COLOR = "#39c63f";
	var PLAYER_TWO_COLOR = "#c73e92";
	var BACKGROUND_COLOR = "#fff";
	
	var helpers = {
		// very cheap version. Hacky.
		mod: function(dividend, modulo) {
			while (dividend < 0) {
				dividend += modulo;
			}
			return dividend % modulo;
		}
	}
	
	var Snake = function(color, field) {
		
		// direction symbols
		var north = 0,
			east = 1,
			south = 2,
			west = 3;
			
		var self = this;
		
		this.needsToBeRendered = true;
		this.color = color;
		this.direction = Math.floor(Math.random() * 4);
		
		// an array of x-y coordinates.
		this.body = [];
		
		// JUST FOR INITIAL TEST:
		this.maxLength = 10;
		// END OF INITIAL TEST CODE.
		
		// Init code
		do {
			this.body[0] = {
				x: Math.floor(Math.random() * field.size),
				y: Math.floor(Math.random() * field.size)
			}
		} while (!field.isEmpty(this.body[0]));
				
		this.move = function() {
			var dx = 0, 
				dy = 0,
			    newHead;
				
			switch(this.direction) {
				case 0: dy -= 1; break; // north
				case 1: dx += 1; break; // east
				case 2: dy += 1; break; // south
				case 3: dx -= 1;			// west
			}
			
			newHead = {
				x: this.body[0].x + dx,
				y: this.body[0].y + dy
			};
			
			if (field.isInBounds(newHead) && field.isEmpty(newHead)) {
				this.body.unshift(newHead);
				field.grid[newHead.x][newHead.y] = 'snake';
				this.needToAddHead = true;				
				if (this.body.length > this.maxLength) {
					this.body.length -= 1;
					this.needToRemoveTail = true;
				}
			} else {
				this.needToAddHead = false;
				this.needToRemoveTail = false;
				if (field.isSurrounded(location)) {
					// TODO: Have something actually happen when the user can't move any more. 	
				}
			}
		}
	}
	
	var Field = function(size) {
		
		var self = this;

		this.size = size;
		this.snakes = [];
		this.grid = _.map(_.range(0, size), function () {
			return []; 
		});	
		
		this.addSnake = function(snake) {
			this.snakes.push(snake);
		}
		
		this.isInBounds = function(location) {
			var x = location.x;
			var y = location.y;
			return (x >= 0 && x < size && y >= 0 && y < size);
		}
		
		this.isEmpty = function(location) {
			return !this.grid[location.x][location.y];
		}
		
		this.isSurrounded = function(location) {
			var isEmpty = this.isEmpty;
			
			var dx_range = [-1,0,1];
			var dy_range = [-1,0,1];
			_.each(dx_range, function (column) {
				_.each(dy_range, function (row) {
					if (self.isInBounds(location) && self.isEmpty(location)) {
						return false;
					}
				});
			});
			return true;
		}
		
		this.step = function() {
			_.each(this.snakes, function(snake) {
				snake.move();
			})
		}
	}


	var Canvas = function(elementId, field, size) {
		
		var self = this;
		
		this.size = size;
		
		this.el = document.getElementById(elementId);
		this.el.width = size * BLOCK_HEIGHT;
		this.el.height = size * BLOCK_HEIGHT;
		
		var c = this.ctx = this.el.getContext("2d");
		c.lineCap = LINE_CAP;
		c.lineJoin = LINE_JOIN;
		c.lineWidth = 1;
		
		c.strokeStyle = c.fillStyle = BACKGROUND_COLOR;

		
		// Clear screen
		c.fillRect( 0, 0, size * BLOCK_HEIGHT, size * BLOCK_HEIGHT);
		
		var drawCell = function(location, color) {
			c.fillStyle = color;
			var left = location.x * BLOCK_HEIGHT + 1;
			var top = location.y * BLOCK_HEIGHT + 1;
			c.fillRect( left, top, BLOCK_HEIGHT, BLOCK_HEIGHT );
			c.strokeRect( left, top, BLOCK_HEIGHT, BLOCK_HEIGHT );			
		}
		
		eraseCell = function(location) {
			c.fillStyle = BACKGROUND_COLOR;
			var left = location.x * BLOCK_HEIGHT + 1;
			var top = location.y * BLOCK_HEIGHT + 1;
			c.fillRect( left, top, BLOCK_HEIGHT, BLOCK_HEIGHT );
		}
		
		var render = function() {
			_.each(field.snakes, function(snake) {
				var c = self.ctx;
				if (snake.needToAddHead) {
					drawCell(snake.body[0], snake.color);
				}
				if (snake.needToRemoveTail) {
					eraseCell(snake.body[snake.body.length - 1]);
				}
			});
			
		}
		this.step = function() {
			// Renders first, so we don't even need to have a startSnake method.
			render();
			field.step();
		}
	}

	var field = new Field(GRID_SIZE);
	var snakeOne = new Snake(PLAYER_ONE_COLOR, field);
	var snakeTwo = new Snake(PLAYER_TWO_COLOR, field);
	field.addSnake(snakeOne);
	field.addSnake(snakeTwo);
	
	var canvas = new Canvas('mainCanvas', field, GRID_SIZE);
	
	var interval = setInterval (canvas.step, INTERVAL_TIME);
	
	// Event handlers:
	$('body').on('keydown', function(e) {
		console.log(e.which);
		if (e.which === 74 || e.which === 106) {
			console.log('left');
			snakeOne.direction = helpers.mod(snakeOne.direction + 1, 4);
		}
		if (e.which === 106 || e.which === 107) {
			console.log('right');
			snakeOne.direction = helpers.mod(snakeOne.direction - 1, 4);
		}
	});
	
	
	
	
	$('body').on('keypress', function(e) {
		if (e.which === 27) {
			clearInterval(interval);
			alert("We're out of here.");
		}
	});

</script>
	
</body>
</html>